From d7cf62cf9f630975a0e876708c4a23907a23aba3 Mon Sep 17 00:00:00 2001
From: Petr Viktorin <encukou@gmail.com>
Date: Wed, 31 Jul 2024 00:19:48 +0200
Origin: backport, https://github.com/python/cpython/pull/122611

Per RFC 2047:

> [...] these encoding schemes allow the
> encoding of arbitrary octet values, mail readers that implement this
> decoding should also ensure that display of the decoded data on the
> recipient's terminal will not cause unwanted side-effects

It seems that the "quoted-word" scheme is a valid way to include
a newline character in a header value, just like we already allow
undecodable bytes or control characters.
They do need to be properly quoted when serialized to text, though.

This should fail for custom fold() implementations that aren't careful
about newlines.

(cherry picked from commit 097633981879b3c9de9a1dd120d3aa585ecc2384)

Co-authored-by: Petr Viktorin <encukou@gmail.com>
Co-authored-by: Bas Bloemsaat <bas@bloemsaat.org>
Co-authored-by: Serhiy Storchaka <storchaka@gmail.com>

--- python2.7-2.7.18.orig/Lib/email/errors.py
+++ python2.7-2.7.18/Lib/email/errors.py
@@ -55,3 +55,6 @@ class MalformedHeaderDefect(MessageDefec
 
 class MultipartInvariantViolationDefect(MessageDefect):
     """A message claimed to be a multipart but no subparts were found."""
+
+class HeaderWriteError(MessageError):
+    """Error while writing headers."""
--- python2.7-2.7.18.orig/Lib/email/generator.py
+++ python2.7-2.7.18/Lib/email/generator.py
@@ -13,11 +13,13 @@ import warnings
 
 from cStringIO import StringIO
 from email.header import Header
+from email.errors import HeaderWriteError
 
 UNDERSCORE = '_'
 NL = '\n'
 
 fcre = re.compile(r'^From ', re.MULTILINE)
+NEWLINE_WITHOUT_FWSP = re.compile(r'\r\n[^ \t]|\r[^ \n\t]|\n[^ \t]')
 
 def _is8bitstring(s):
     if isinstance(s, str):
@@ -139,6 +141,9 @@

     def _write_headers(self, msg):
         for h, v in msg.items():
+            if NEWLINE_WITHOUT_FWSP.search(h):
+                raise HeaderWriteError(
+                        'header contains newline: %s' % h)
             print >> self._fp, '%s:' % h,
             if self._maxheaderlen == 0:
                 # Explicit no-wrapping
--- python2.7-2.7.18.orig/Lib/email/header.py
+++ python2.7-2.7.18/Lib/email/header.py
@@ -24,6 +24,7 @@ SPACE = ' '
 USPACE = u' '
 SPACE8 = ' ' * 8
 UEMPTYSTRING = u''
+NLSET = {'\n', '\r'}
 
 MAXLINELEN = 76
 
@@ -360,6 +361,8 @@ class Header:
                 continue
             if charset is None or charset.header_encoding is None:
                 s = header
+            elif any(nl in header for nl in NLSET):
+                s = charset.header_encode(header)
             else:
                 s = charset.header_encode(header)
             # Don't add more folding whitespace than necessary
--- python2.7-2.7.18.orig/Lib/email/test/test_email_renamed.py
+++ python2.7-2.7.18/Lib/email/test/test_email_renamed.py
@@ -2580,6 +2580,22 @@
         eq(headers, ['A', 'B', 'CC'])
         eq(msg.get_payload(), 'body')
 
+    def test_verify_generated_headers(self):
+        """Test that the generator prevents header injection"""
+        msg = Message() 
+        value_to_test = 'Value\r\nBad Injection\r\n'
+        h = Header("sample_header_value", header_name=value_to_test)
+        msg[value_to_test] = h
+        sfp = StringIO()
+        g = Generator(sfp)
+    
+        # Expect an exception for invalid header values
+        try:
+            g.flatten(msg)
+            self.fail("HeaderWriteError was not raised for input: %s" % value_to_test)
+        except email.errors.HeaderWriteError:
+            pass
+
 
 
 class TestBase64(unittest.TestCase):
