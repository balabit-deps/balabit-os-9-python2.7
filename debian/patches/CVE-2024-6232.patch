Subject: CVE-2024-6232
From: Seth Michael Larson <seth@python.org>
Date: Tue, 3 Sep 2024 10:07:53 -0500

gh-121285: Remove backtracking when parsing tarfile headers (GH-121286) (#123640)

* Remove backtracking when parsing tarfile headers
* Rewrite PAX header parsing to be stricter
* Optimize parsing of GNU extended sparse headers v0.0

(cherry picked from commit 34ddb64d088dd7ccc321f6103d23153256caa5d4)

[backport]
Minimal backport only one regex of 2.7 is vulnerable

Co-authored-by: Kirill Podoprigora <kirill.bast9@mail.ru>
Co-authored-by: Gregory P. Smith <greg@krypto.org>
origin: backport, https://github.com/python/cpython/commit/743acbe872485dc18df4d8ab2dc7895187f062c4.patch
bug: https://github.com/python/cpython/issues/121285
bug-freexian-security: https://deb.freexian.com/extended-lts/tracker/CVE-2024-6232

--- python2.7-2.7.18.orig/Lib/tarfile.py
+++ python2.7-2.7.18/Lib/tarfile.py
@@ -918,6 +918,9 @@ class ExFileObject(object):
             yield line
 #class ExFileObject
 
+# Header length is digits followed by a space.
+_header_length_prefix_re = re.compile(br"([0-9]{1,20}) ")
+
 #------------------
 # Exported Classes
 #------------------
@@ -1393,22 +1396,32 @@ class TarInfo(object):
         # the newline. keyword and value are both UTF-8 encoded strings.
         regex = re.compile(r"(\d+) ([^=]+)=", re.U)
         pos = 0
-        while True:
-            match = regex.match(buf, pos)
+        while len(buf) > pos and buf[pos] != 0x00:
+            match = _header_length_prefix_re.match(buf, pos)
             if not match:
-                break
+                raise InvalidHeaderError("invalid header")
+            try:
+                length = int(match.group(1))
+            except ValueError:
+                raise InvalidHeaderError("invalid header")
+            # Headers must be at least 5 bytes, shortest being '5 x=\n'.
+            # Value is allowed to be empty.
+            if length < 5:
+                raise InvalidHeaderError("invalid header")
+            if pos + length > len(buf):
+                raise InvalidHeaderError("invalid header")
 
-            length, keyword = match.groups()
-            length = int(length)
-            if length == 0:
+            header_value_end_offset = match.start(1) + length - 1  # Last byte of the header
+            keyword_and_value = buf[match.end(1) + 1:header_value_end_offset]
+            raw_keyword, equals, raw_value = keyword_and_value.partition(b"=")
+            # Check the framing of the header. The last character must be '\n' (0x0A)
+            if not raw_keyword or equals != b"=" or buf[header_value_end_offset] != 0x0A:
                 raise InvalidHeaderError("invalid header")
-            value = buf[match.end(2) + 1:match.start(1) + length - 1]
 
-            keyword = keyword.decode("utf8")
-            value = value.decode("utf8")
+            keyword = raw_keyword.decode("utf8")
+            value = raw_value.decode("utf8")
 
             pax_headers[keyword] = value
-            pos += length
 
         # Fetch the next header.
         try:
